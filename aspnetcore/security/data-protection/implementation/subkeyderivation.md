---
title: ASP.NET Core でのサブキーの派生と認証された暗号化
author: rick-anderson
description: ASP.NET Core データ保護サブキーの派生と認証された暗号化の実装の詳細について説明します。
ms.author: riande
ms.date: 10/14/2016
no-loc:
- 'appsettings.json'
- 'ASP.NET Core Identity'
- 'cookie'
- 'Cookie'
- 'Blazor'
- 'Blazor Server'
- 'Blazor WebAssembly'
- 'Identity'
- "Let's Encrypt"
- 'Razor'
- 'SignalR'
uid: security/data-protection/implementation/subkeyderivation
ms.openlocfilehash: efe8ad2f71feda9cbc1693d362e30eff29cbcd74
ms.sourcegitcommit: ca34c1ac578e7d3daa0febf1810ba5fc74f60bbf
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 10/30/2020
ms.locfileid: "93060158"
---
# <a name="subkey-derivation-and-authenticated-encryption-in-aspnet-core"></a><span data-ttu-id="8e4a7-103">ASP.NET Core でのサブキーの派生と認証された暗号化</span><span class="sxs-lookup"><span data-stu-id="8e4a7-103">Subkey derivation and authenticated encryption in ASP.NET Core</span></span>

<a name="data-protection-implementation-subkey-derivation"></a>

<span data-ttu-id="8e4a7-104">キーリングのほとんどのキーには何らかの形式のエントロピが含まれ、"CBC-mode encryption + HMAC validation" または "GCM encryption + validation" というアルゴリズム情報が含まれます。</span><span class="sxs-lookup"><span data-stu-id="8e4a7-104">Most keys in the key ring will contain some form of entropy and will have algorithmic information stating "CBC-mode encryption + HMAC validation" or "GCM encryption + validation".</span></span> <span data-ttu-id="8e4a7-105">このような場合は、このキーのマスターキーマテリアル (または KM) として埋め込みエントロピを参照し、実際の暗号化操作に使用するキーを派生させるキー派生関数を実行します。</span><span class="sxs-lookup"><span data-stu-id="8e4a7-105">In these cases, we refer to the embedded entropy as the master keying material (or KM) for this key, and we perform a key derivation function to derive the keys that will be used for the actual cryptographic operations.</span></span>

> [!NOTE]
> <span data-ttu-id="8e4a7-106">キーは抽象的であり、カスタム実装は次のように動作しない可能性があります。</span><span class="sxs-lookup"><span data-stu-id="8e4a7-106">Keys are abstract, and a custom implementation might not behave as below.</span></span> <span data-ttu-id="8e4a7-107">`IAuthenticatedEncryptor`組み込みのファクトリのいずれかを使用するのではなく、キーが独自のを実装する場合、このセクションで説明するメカニズムは適用されなくなります。</span><span class="sxs-lookup"><span data-stu-id="8e4a7-107">If the key provides its own implementation of `IAuthenticatedEncryptor` rather than using one of our built-in factories, the mechanism described in this section no longer applies.</span></span>

<a name="data-protection-implementation-subkey-derivation-aad"></a>

## <a name="additional-authenticated-data-and-subkey-derivation"></a><span data-ttu-id="8e4a7-108">追加の認証データとサブキーの派生</span><span class="sxs-lookup"><span data-stu-id="8e4a7-108">Additional authenticated data and subkey derivation</span></span>

<span data-ttu-id="8e4a7-109">インターフェイスは、 `IAuthenticatedEncryptor` 認証されたすべての暗号化操作のコアインターフェイスとして機能します。</span><span class="sxs-lookup"><span data-stu-id="8e4a7-109">The `IAuthenticatedEncryptor` interface serves as the core interface for all authenticated encryption operations.</span></span> <span data-ttu-id="8e4a7-110">この `Encrypt` メソッドは、プレーンテキストと Additional認証 Ateddata (AAD) という2つのバッファーを受け取ります。</span><span class="sxs-lookup"><span data-stu-id="8e4a7-110">Its `Encrypt` method takes two buffers: plaintext and additionalAuthenticatedData (AAD).</span></span> <span data-ttu-id="8e4a7-111">プレーンテキストコンテンツは、の呼び出しを変更せずにフローします `IDataProtector.Protect` が、AAD はシステムによって生成され、3つのコンポーネントで構成されます。</span><span class="sxs-lookup"><span data-stu-id="8e4a7-111">The plaintext contents flow unchanged the call to `IDataProtector.Protect`, but the AAD is generated by the system and consists of three components:</span></span>

1. <span data-ttu-id="8e4a7-112">このバージョンのデータ保護システムを識別する32ビットマジックヘッダー 09 F0 C9 F0。</span><span class="sxs-lookup"><span data-stu-id="8e4a7-112">The 32-bit magic header 09 F0 C9 F0 that identifies this version of the data protection system.</span></span>

2. <span data-ttu-id="8e4a7-113">128ビットキー id。</span><span class="sxs-lookup"><span data-stu-id="8e4a7-113">The 128-bit key id.</span></span>

3. <span data-ttu-id="8e4a7-114">この操作を実行しているを作成した目的のチェーンから形成された可変長文字列。 `IDataProtector`</span><span class="sxs-lookup"><span data-stu-id="8e4a7-114">A variable-length string formed from the purpose chain that created the `IDataProtector` that's performing this operation.</span></span>

<span data-ttu-id="8e4a7-115">AAD は3つのすべてのコンポーネントの組に対して一意であるため、すべての暗号化操作で KM 自体を使用するのではなく、それを使用して KM から新しいキーを派生させることができます。</span><span class="sxs-lookup"><span data-stu-id="8e4a7-115">Because the AAD is unique for the tuple of all three components, we can use it to derive new keys from KM instead of using KM itself in all of our cryptographic operations.</span></span> <span data-ttu-id="8e4a7-116">を呼び出すたびに `IAuthenticatedEncryptor.Encrypt` 、次のキー派生プロセスが実行されます。</span><span class="sxs-lookup"><span data-stu-id="8e4a7-116">For every call to `IAuthenticatedEncryptor.Encrypt`, the following key derivation process takes place:</span></span>

`( K_E, K_H ) = SP800_108_CTR_HMACSHA512(K_M, AAD, contextHeader || keyModifier)`

<span data-ttu-id="8e4a7-117">ここでは、カウンタモードで NIST SP800-108 KDF を呼び出しています ( [NIST SP800-108](https://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-108.pdf), Sec. 5.1 を参照)。次のパラメーターがあります。</span><span class="sxs-lookup"><span data-stu-id="8e4a7-117">Here, we're calling the NIST SP800-108 KDF in Counter Mode (see [NIST SP800-108](https://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-108.pdf), Sec. 5.1) with the following parameters:</span></span>

* <span data-ttu-id="8e4a7-118">キー派生キー (KDK) = `K_M`</span><span class="sxs-lookup"><span data-stu-id="8e4a7-118">Key derivation key (KDK) = `K_M`</span></span>

* <span data-ttu-id="8e4a7-119">PRF = HMACSHA512</span><span class="sxs-lookup"><span data-stu-id="8e4a7-119">PRF = HMACSHA512</span></span>

* <span data-ttu-id="8e4a7-120">ラベル = Additional認証 Ateddata</span><span class="sxs-lookup"><span data-stu-id="8e4a7-120">label = additionalAuthenticatedData</span></span>

* <span data-ttu-id="8e4a7-121">context = contextHeader | |keyModifier</span><span class="sxs-lookup"><span data-stu-id="8e4a7-121">context = contextHeader || keyModifier</span></span>

<span data-ttu-id="8e4a7-122">コンテキストヘッダーは可変長であり、基本的には、とを派生させるアルゴリズムの拇印として機能し `K_E` `K_H` ます。</span><span class="sxs-lookup"><span data-stu-id="8e4a7-122">The context header is of variable length and essentially serves as a thumbprint of the algorithms for which we're deriving `K_E` and `K_H`.</span></span> <span data-ttu-id="8e4a7-123">キー修飾子は、の各呼び出しに対してランダムに生成された128ビット文字列であり、 `Encrypt` KDF への他のすべての入力が定数であっても、KH がこの特定の認証暗号化操作に対して一意であることを保証するために役立ちます。</span><span class="sxs-lookup"><span data-stu-id="8e4a7-123">The key modifier is a 128-bit string randomly generated for each call to `Encrypt` and serves to ensure with overwhelming probability that KE and KH are unique for this specific authentication encryption operation, even if all other input to the KDF is constant.</span></span>

<span data-ttu-id="8e4a7-124">CBC モード暗号化 + HMAC 検証操作の場合、 `| K_E |` は対称ブロック暗号キーの長さで、 `| K_H |` は hmac ルーチンのダイジェストサイズです。</span><span class="sxs-lookup"><span data-stu-id="8e4a7-124">For CBC-mode encryption + HMAC validation operations, `| K_E |` is the length of the symmetric block cipher key, and `| K_H |` is the digest size of the HMAC routine.</span></span> <span data-ttu-id="8e4a7-125">GCM 暗号化 + 検証操作の場合は、 `| K_H | = 0` 。</span><span class="sxs-lookup"><span data-stu-id="8e4a7-125">For GCM encryption + validation operations, `| K_H | = 0`.</span></span>

## <a name="cbc-mode-encryption--hmac-validation"></a><span data-ttu-id="8e4a7-126">CBC モード暗号化 + HMAC 検証</span><span class="sxs-lookup"><span data-stu-id="8e4a7-126">CBC-mode encryption + HMAC validation</span></span>

<span data-ttu-id="8e4a7-127">`K_E`上記のメカニズムを使用してが生成されたら、ランダムな初期化ベクターを生成し、対称ブロック暗号アルゴリズムを実行してプレーンテキストを暗号化します。</span><span class="sxs-lookup"><span data-stu-id="8e4a7-127">Once `K_E` is generated via the above mechanism, we generate a random initialization vector and run the symmetric block cipher algorithm to encipher the plaintext.</span></span> <span data-ttu-id="8e4a7-128">次に、初期化ベクターと暗号化テキストを、キーで初期化された HMAC ルーチンを通じて実行し、 `K_H` MAC を生成します。</span><span class="sxs-lookup"><span data-stu-id="8e4a7-128">The initialization vector and ciphertext are then run through the HMAC routine initialized with the key `K_H` to produce the MAC.</span></span> <span data-ttu-id="8e4a7-129">このプロセスと戻り値は、次のようにグラフィカルに表示されます。</span><span class="sxs-lookup"><span data-stu-id="8e4a7-129">This process and the return value is represented graphically below.</span></span>

![CBC モードのプロセスと戻り値](subkeyderivation/_static/cbcprocess.png)

`output:= keyModifier || iv || E_cbc (K_E,iv,data) || HMAC(K_H, iv || E_cbc (K_E,iv,data))`

> [!NOTE]
> <span data-ttu-id="8e4a7-131">`IDataProtector.Protect`実装では、出力する[マジックヘッダーとキー id](xref:security/data-protection/implementation/authenticated-encryption-details)が、呼び出し元に返される前に付加されます。</span><span class="sxs-lookup"><span data-stu-id="8e4a7-131">The `IDataProtector.Protect` implementation will [prepend the magic header and key id](xref:security/data-protection/implementation/authenticated-encryption-details) to output before returning it to the caller.</span></span> <span data-ttu-id="8e4a7-132">マジックヘッダーとキー id は暗黙的に [AAD](xref:security/data-protection/implementation/subkeyderivation#data-protection-implementation-subkey-derivation-aad)に含まれるため、キー修飾子は kdf に入力として渡されるため、最終的に返されるペイロードのすべての1バイトが MAC によって認証されます。</span><span class="sxs-lookup"><span data-stu-id="8e4a7-132">Because the magic header and key id are implicitly part of [AAD](xref:security/data-protection/implementation/subkeyderivation#data-protection-implementation-subkey-derivation-aad), and because the key modifier is fed as input to the KDF, this means that every single byte of the final returned payload is authenticated by the MAC.</span></span>

## <a name="galoiscounter-mode-encryption--validation"></a><span data-ttu-id="8e4a7-133">Galois/カウンタモードの暗号化 + 検証</span><span class="sxs-lookup"><span data-stu-id="8e4a7-133">Galois/Counter Mode encryption + validation</span></span>

<span data-ttu-id="8e4a7-134">`K_E`上記のメカニズムを使用してが生成されたら、ランダムな96ビット nonce を生成し、対称ブロック暗号アルゴリズムを実行してプレーンテキストを暗号化し、128ビット認証タグを生成します。</span><span class="sxs-lookup"><span data-stu-id="8e4a7-134">Once `K_E` is generated via the above mechanism, we generate a random 96-bit nonce and run the symmetric block cipher algorithm to encipher the plaintext and produce the 128-bit authentication tag.</span></span>

![GCM モードのプロセスと戻り値](subkeyderivation/_static/galoisprocess.png)

`output := keyModifier || nonce || E_gcm (K_E,nonce,data) || authTag`

> [!NOTE]
> <span data-ttu-id="8e4a7-136">GCM は、AAD の概念をネイティブでサポートしていますが、引き続き、元の KDF にのみ AAD を供給し、AAD パラメーターの空の文字列を GCM に渡すことをオプトインします。</span><span class="sxs-lookup"><span data-stu-id="8e4a7-136">Even though GCM natively supports the concept of AAD, we're still feeding AAD only to the original KDF, opting to pass an empty string into GCM for its AAD parameter.</span></span> <span data-ttu-id="8e4a7-137">この理由は2つのフォールドです。</span><span class="sxs-lookup"><span data-stu-id="8e4a7-137">The reason for this is two-fold.</span></span> <span data-ttu-id="8e4a7-138">まず、 [機敏性をサポートするために](xref:security/data-protection/implementation/context-headers#data-protection-implementation-context-headers) 、 `K_M` 暗号化キーとして直接使用することは避けたいと考えています。</span><span class="sxs-lookup"><span data-stu-id="8e4a7-138">First, [to support agility](xref:security/data-protection/implementation/context-headers#data-protection-implementation-context-headers) we never want to use `K_M` directly as the encryption key.</span></span> <span data-ttu-id="8e4a7-139">さらに、GCM では、入力に対して非常に厳密な一意性要件が課されます。</span><span class="sxs-lookup"><span data-stu-id="8e4a7-139">Additionally, GCM imposes very strict uniqueness requirements on its inputs.</span></span> <span data-ttu-id="8e4a7-140">GCM 暗号化ルーチンが、同じ (キー、nonce) ペアを持つ2つ以上の個別の入力データセットに対して呼び出される確率は、2 ^ 32 を超えることはできません。</span><span class="sxs-lookup"><span data-stu-id="8e4a7-140">The probability that the GCM encryption routine is ever invoked on two or more distinct sets of input data with the same (key, nonce) pair must not exceed 2^32.</span></span> <span data-ttu-id="8e4a7-141">この問題を解決した場合、2 ^ `K_E` 32 を超える暗号化操作を実行する前に、32の制限の afoul を実行することはできません。</span><span class="sxs-lookup"><span data-stu-id="8e4a7-141">If we fix `K_E` we cannot perform more than 2^32 encryption operations before we run afoul of the 2^-32 limit.</span></span> <span data-ttu-id="8e4a7-142">非常に多くの操作が行われているように見えますが、高トラフィックの web サーバーでは、これらのキーの通常の有効期間内に、わずか数日で40億の要求を通過させることができます。</span><span class="sxs-lookup"><span data-stu-id="8e4a7-142">This might seem like a very large number of operations, but a high-traffic web server can go through 4 billion requests in mere days, well within the normal lifetime for these keys.</span></span> <span data-ttu-id="8e4a7-143">2 ^-32 の確率制限に準拠したままにするため、128ビットのキー修飾子と96ビットの nonce が引き続き使用されます。これにより、任意のの使用可能な操作数が大幅に拡張され `K_M` ます。</span><span class="sxs-lookup"><span data-stu-id="8e4a7-143">To stay compliant of the 2^-32 probability limit, we continue to use a 128-bit key modifier and 96-bit nonce, which radically extends the usable operation count for any given `K_M`.</span></span> <span data-ttu-id="8e4a7-144">設計を簡単にするために、CBC 操作と GCM 操作の間で KDF コードパスを共有しています。 AAD は既に KDF で検討されているため、GCM ルーチンに転送する必要はありません。</span><span class="sxs-lookup"><span data-stu-id="8e4a7-144">For simplicity of design we share the KDF code path between CBC and GCM operations, and since AAD is already considered in the KDF there's no need to forward it to the GCM routine.</span></span>
